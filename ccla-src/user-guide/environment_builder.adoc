
= Overview =
ifndef::imagesdir[:imagesdir: images]

== Integration ==

Two mode supported per providers

* Greenfield : create a fresh ressource

* Brownfield : import / discover an existing ressource

Below the matrix of supported clouds :

=== Kubernetes services ===

[cols="1,1,1,1"]
|===
| |Name|Mode|WebSite

|image:providers/EKS.png[EKS,40]
|Amazon Elastic Kubernetes Service
|Greenfield
|https://aws.amazon.com/eks/


|image:AKS.png[AKS,40]
|Azure Kubernetes Service
|Greenfield
|https://azure.microsoft.com/en-us/products/kubernetes-service/

|image:GKE.png[GKE,40]
|Google Kubernetes Engine
|Greenfield
|https://cloud.google.com/kubernetes-engine

|image:NK8.png[NK8,40]
|Native Kubernetes
|Brownfield 
|https://kubernetes.io

|===

=== Virtual machines ===

[cols="1,1,1,1"]
|===
| |Name|Mode|WebSite

|image:EC2.png[EC2,40]
|Amazon EC2
|Greenfield
|https://aws.amazon.com/ec2/

|===

== Blueprints ==

The catalog view

=== OpenMSA Library ===

* Wordpress on Azure

image:Wordpress on Azure.png[100]

* Wordpress on Azure (Demo)
* Multi clouds
* MsaActivator (To be confirmed)

=== User Library ===

== Quick Deployment ==

== The wizard ==

=== Providers specificity ===

=== GKE ===

=== Native K8 import ===

4 fields are needed to import an existing K8 platform in Cloudclapp

* **API Server IP/Host** : This value is usually the IP address of the Master Node in the Kubernetes cluster

* **API Server Port** :The API server is generally exposed on the port 6443 by default. Cloudclapp will check if the specific port on the given IP is reachable before Import. In a kubeconfig file, both of the above values are in the server field for a cluster

* **Certificate Authority Data** : Certificat generated 

* **Kubernetes Service Account Token** : Token associated with a service account. This service account can then be bound to a cluster role to provide granular access across the K8s cluster.

NOTE: Check the appendix below to have more details to how retrieve those informations

== Designer ==

== Environement dashboard ==

=== Monitoring ===

== Details of WF steps ==

[cols="1,1"]
|===
|Steps|Description

|Create TF Workspace
|tt

|Set TF variables values
|

|Initialize TF Workspace
|

|Provision AKS cluster
|

|Create AKS Cluster Managed Entity
|

|Get AKS Cluster Dashboard
|

|Deploy Prometheus and Grafana
|

|Trigger compliance scan
|

|===

== Appendix ==
=== K8 service token and certificate ===

In order to access the K8s APIs, CCLA requires a token associated with a service account. This service account can then be bound to a cluster role to provide granular access across the K8s cluster.

Create YAML files for serviceaccount, clusterrole and clusterrolebinding
----
apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: "2023-02-23T10:54:04Z"
  name: ccla-service-account
  namespace: default
----
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: ccla-cluster-role
rules:
- apiGroups:
  - ""
  - apps
  - extensions
  resources:
  - pods
  - pods/log
  - configmaps
  - daemonsets
  - deployments
  - jobs
  - namespaces
  - nodes
  - persistentvolumes
  - persistentvolumeclaims
  - replicasets
  - replicationcontrollers
  - serviceaccounts
  - services
  - secrets
  verbs:
  - get
  - list
  - create
  - update
  - patch
  - delete
----
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: ccla-cluster-role-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: ccla-cluster-role
subjects:
- kind: ServiceAccount
  name: ccla-service-account
  namespace: default
----
Use kubectl to apply these resources

----
kubectl apply -f serviceaccount.yaml
kubectl apply -f clusterrole.yaml
kubectl apply -f clusterrolebinding.yaml
----

Now create a secret that will hold the token for the service account

----
apiVersion: v1
kind: Secret
type: kubernetes.io/service-account-token
metadata:
  name: ccla-token
  annotations:
    kubernetes.io/service-account.name: ccla-service-account
----
----
kubectl apply -f secret.yaml
----
The above secret should contain the CA data and Token required as inputs for CCLA. To get the values from the secret, run kubectl get secret ccla-token -oyaml
This command with display the data stored in YAML format.

----
apiVersion: v1
data:
  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUJkekNDQVIyZ0F3SUJBZ0lCQURBS0JnZ3Foa2pPUFFRREFqQWpNU2dZSUtvWkl6ajBFQXdJRFNBQXdSUUlnSzBRN3hHTm12T3p3MEZTUTNEUVpMNlJ0Nzc3ejZVRDUKbU8xT3RSZ2NhR2dDSVFDdU56OTVDdk9hWVZiQzFlT3BkQi96LzVSaXprV1lmbkNVYzc3Y1VBQzBzZz09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
  namespace: ZGVmYXVsdA==
  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNkluRjNNRWxrUmt4WWVYRkZNSFJ5ZGtzNE5EY3hPV3R2ZVhKNVMyUjRNSEZEYzNRMlNrcDZTblU1V2pnaWZRLmV5SnBjM01pT2lKcmRXSmxjbTVsZEdWekwzTmxjblpwWTJWaFkyTnZkVzUwSWl3aWEzVmlaWEp1WlhSbGN5NXBieTl6WlhKMmFXTmxZV05qYjNWdWRDOXVZVzFsYzNCaFkyVWlPaUprWldaaGRXeDBJaXdpYTNWaVpYSnVaWFJsY3k1cGJ5OXpaWEoyYVdObFlXTmpiM1Z1ZEM5cDNxZWhETWpGUk1DM0ZmWlJTZzV6MzVfTGltYTFKX3hXdHcwLWUzLTVlakJ6d0tWQ1NoOXlNQjY4TDZjY3duOUZ1R2dMWDBzV2JFMDJ6WnBhNFJicnVBcUJjTU5PbXpJaW9HRUJpeUdoZXRoZmx6eHpmZjZidXBnLXFUdktEYnVuWWlpajE2MkxrYnVJdmZNQTNJaktsbWpyNTRudWFPbngwUW14ODNOUXZITkZOb2hzMXM2cm5hcEV3VXhycC0yWkFjYVdn
kind: Secret
metadata:
  name: api-token
  namespace: default
type: kubernetes.io/service-account-token
----
NOTE: The above data is base64 encoded
